{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.linearBackOff = exports.getElapsedLinearSeconds = exports.expBackOff = exports.getElapsedExpSeconds = exports.sleep = void 0;\n\nconst time_1 = require(\"./time\");\n\nfunction sleep(ms) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  });\n}\n\nexports.sleep = sleep;\n\nfunction getExpBackOffSeconds(attempts) {\n  return Math.pow(2, attempts);\n}\n\nfunction getLinearBackOffSeconds(attempts, intervalSeconds) {\n  return (attempts + 1) * intervalSeconds;\n}\n\nfunction getElapsedExpSeconds(config) {\n  if (!config.intervalSeconds) {\n    throw new Error(\"intervalSeconds is required for getElapsedLinearTime\");\n  }\n\n  let elapsedSeconds = 0;\n\n  for (let i = 0; i < config.attempts; i++) {\n    elapsedSeconds += getExpBackOffSeconds(i);\n  }\n\n  return elapsedSeconds;\n}\n\nexports.getElapsedExpSeconds = getElapsedExpSeconds;\n\nfunction expBackOff(config) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (!config.intervalSeconds) {\n      throw new Error(\"intervalSeconds is required for getElapsedLinearTime\");\n    }\n\n    let elapsedSeconds = getElapsedExpSeconds(config);\n    let shouldContinueBackoff = true;\n\n    if (elapsedSeconds / 60 > config.timeoutMinutes) {\n      shouldContinueBackoff = false;\n      return shouldContinueBackoff;\n    }\n\n    const msToSleep = (0, time_1.secToMs)(getExpBackOffSeconds(config.attempts * config.intervalSeconds));\n    yield sleep(msToSleep);\n    return shouldContinueBackoff;\n  });\n}\n\nexports.expBackOff = expBackOff;\n\nfunction getElapsedLinearSeconds(config) {\n  if (!config.intervalSeconds) {\n    throw new Error(\"intervalSeconds is required for getElapsedLinearTime\");\n  }\n\n  let elapsedSeconds = 0;\n\n  for (let i = 0; i < config.attempts; i++) {\n    elapsedSeconds += getLinearBackOffSeconds(i, config.intervalSeconds);\n  }\n\n  return elapsedSeconds;\n}\n\nexports.getElapsedLinearSeconds = getElapsedLinearSeconds;\n\nfunction linearBackOff(config) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (!config.intervalSeconds) {\n      throw new Error(\"intervalSeconds is required for linearBackOff\");\n    }\n\n    let elapsedSeconds = getElapsedLinearSeconds(config);\n    let shouldContinueBackoff = true;\n\n    if (elapsedSeconds / 60 > config.timeoutMinutes) {\n      shouldContinueBackoff = false;\n      return shouldContinueBackoff;\n    }\n\n    const msToSleep = (0, time_1.secToMs)(getLinearBackOffSeconds(config.attempts, config.intervalSeconds));\n    yield sleep(msToSleep);\n    return shouldContinueBackoff;\n  });\n}\n\nexports.linearBackOff = linearBackOff; //# sourceMappingURL=sleep.js.map","map":null,"metadata":{},"sourceType":"script"}